
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

    <title>一步步教你手写Promise</title>

    
    <meta name="description" content="">
    

    <meta name="author" content="Howard.Zuo">

    <!-- Enable responsive viewport -->
    <meta name="viewport" content="user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimal-ui"/>
    
    
    <base href="/">
    

    
    <base href="/">
    

    <!-- materiallize styles -->
    <link href="/assets/themes/materiallize/css/materialize.min.css" rel="stylesheet">
    <!-- fontawesome styles -->
    <link href="/assets/themes/materiallize/css/font-awesome.min.css" rel="stylesheet">
    <!-- tooltipster styles -->
    <link href="/assets/themes/materiallize/css/tooltipster.css" rel="stylesheet">
    <!-- prism styles -->
    <link href="/assets/themes/materiallize/css/prism.css" rel="stylesheet">
    
    <!-- Custom styles -->
    <link href="/assets/themes/materiallize/css/style.css" rel="stylesheet" type="text/css" media="all">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="/assets/themes/materiallize/js/html5shiv.js"></script>
      <script src="/assets/themes/materiallize/js/respond.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <link rel="shortcut icon" href="/assets/images/favicon.ico">
    <link rel="apple-touch-icon" href="/assets/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/assets/images/apple-touch-icon-114x114.png">

    <script type="text/javascript" src="/assets/themes/materiallize/js/modernizr.js"></script>

  </head>

  <body>

      <nav class="light-blue lighten-1" role="navigation">
          <div class="nav-wrapper container">
              <a id="logo-container" href="/" class="brand-logo">右领军大都督</a>
              <ul class="right hide-on-med-and-down">
                  
                  
                  


  
    
  
    
      
          
          <li><a href="/index.html" lang="HOME"></a></li>
          
      
    
  
    
      
          
          <li><a href="/archive.html" lang="ARCHIVE"></a></li>
          
      
    
  
    
      
          
          <li><a href="/categories.html" lang="CATEGORIES"></a></li>
          
      
    
  
    
      
          
          <li><a href="/tags.html" lang="TAGS"></a></li>
          
      
    
  



              </ul>

              <ul id="nav-mobile" class="side-nav">
                  
                  
                  


  
    
  
    
      
          
          <li><a href="/index.html" lang="HOME"></a></li>
          
      
    
  
    
      
          
          <li><a href="/archive.html" lang="ARCHIVE"></a></li>
          
      
    
  
    
      
          
          <li><a href="/categories.html" lang="CATEGORIES"></a></li>
          
      
    
  
    
      
          
          <li><a href="/tags.html" lang="TAGS"></a></li>
          
      
    
  



              </ul>
              <a href="#" data-activates="nav-mobile" class="button-collapse right"><i class="mdi-navigation-menu"></i></a>
          </div>
      </nav>
      
      <main>
          <div class="container">
              
<div class="row">
    <div class="col s12 m8">
        
        
<p>本文中的例子源码在：<a href="https://github.com/leftstick/promise-tutorial">promise-tutorial</a></p>

<p>你也可以直接clone：</p>

<pre><code class="language-bash">git clone https://github.com/leftstick/promise-tutorial.git
</code></pre>

<p>近几年互联网炙手可热，由此给程序员们带来了极大的刺激(通过市场)。其中最令人羡慕、嫉妒、恨的莫过于前端的火爆。这个以前在IT公司里做最底层技术工作的岗位(又称“页面仔”)，突然一下各种热门，作为前端的我们，是否感到了这个春天了？</p>

<p>说回正题，<code>Promise</code>绝非今日才有，规范在这里<a href="https://promisesaplus.com/">Promise/A+</a>，市面上各种实现鳞次栉比，<a href="http://api.jquery.com/Types/#Promise">jQuery-Promise</a>、<a href="http://bluebirdjs.com/docs/getting-started.html">bluebird</a>、<a href="http://documentup.com/kriskowal/q/">q</a>、<a href="https://docs.angularjs.org/api/ng/service/$q">Angular-$q</a>…，各种的performance较量，语法糖对比，乱花渐欲迷人眼！但究其核心价值，就是解决<code>JavaScript</code>异步编程中的<a href="http://callbackhell.com/">回调王八蛋(callback hell)</a>。那让我们先来回顾一下，<a href="http://callbackhell.com/">callback hell</a>是如何给我们造成<a href="https://en.wikipedia.org/wiki/Technical_debt">技术债务(technical debt)</a>的：</p>

<pre><code class="language-javascript">step1(function (value1) {
    step2(value1, function(value2) {
        step3(value2, function(value3) {
            step4(value3, function(value4) {
                // Do something with value4
            });
        });
    });
});
</code></pre>

<blockquote>
  <p>以上片段，摘自<a href="http://documentup.com/kriskowal/q/">q</a></p>
</blockquote>

<p>然后再来看看，<code>Promise</code>又是如何解决的：</p>

<pre><code class="language-javascript">new Promise(function(resolve, reject){
    step1(resolve);
})
.then(function(value1){
    return step2(value1);
})
.then(function(value2){
    return step3(value2);
})
.then(function(value3){
    return step4(value3);
})
.then(function (value4) {
    // Do something with value4
})
.catch(function (error) {
    // Handle any error from all above steps
})
</code></pre>

<p>如果看到这里你有任何惊奇的感受，那建议先去看看<a href="https://www.promisejs.org/">Promise介绍</a>。本文不会围绕在<code>Promise</code>“该如何使用”上！我们来聊聊，<code>Promise</code>的设计思路和实现方式。</p>

<p>OK，留下的盆友基本已经是”别他妈废话了，赶紧的开始吧，怎么自己手写一个<code>Promise</code>出来”！那我要开始喽，<code>Promise</code>究竟是如何做到这一点的，又有什么玄机在里面？今天我们无图、无说教，全凭代码探秘<code>Promise</code>的傲娇内心世界！</p>

<p><br /></p>

<h4 id="promise">初探江湖，<code>Promise</code>该长什么样儿？</h4>

<p>根据上述代码片段，我们看到<code>Promise</code>的核心功能，就是<code>then</code>方法，那我们先来个定义吧！</p>

<pre><code class="language-javascript">'use strict';
var Promise = function(func) {};

Promise.prototype.then = function(onFulfilled, onRejected) {};

module.exports = Promise;
</code></pre>

<blockquote>
  <p>估计会有盆友风骚的问，为什么没有<code>success</code>、<code>error</code>、<code>catch</code>、<code>finally</code>、<code>done</code>？其实这些方法作为语法糖出现，是为了帮助用户更好的使用<code>Promise</code>，本质上并没有为<code>Promise</code>增加额外属性。我们此行要探索的是真谛，请盆友们暂停躁动的心！^^</p>
</blockquote>

<p><br /></p>

<h4 id="then">为了一个<code>then</code>方法，我们也是拼了</h4>

<p>为了一步步可验证我们的代码，带我们走向人生巅峰，<a href="https://en.wikipedia.org/wiki/Unit_testing">unit test</a>必不可少！来吧，骚年，第一版的<code>ut</code>来了：</p>

<pre><code class="language-javascript">'use strict';
var PPP = require('../Promise');

describe('Promise', function() {
    it('then is called', function(done) {
        var onFulfilled = sinon.spy();
        new PPP(function(resolve, reject) {
            resolve();
        })
        .then(onFulfilled);

        setTimeout(function() {
            //验证下onFulfilled方法是否被调用了
            should(onFulfilled.called).be.true();
            done();
        }, 100);
    });
});
</code></pre>
<blockquote>
  <p>咦！这里一定有盆友问，那个<code>should</code>为啥非要等100ms再执行！？理由也简单，因为<code>Promise</code>是异步操作，我做了个假设，这些异步操作都会在100ms内执行完毕。</p>
</blockquote>

<p>当我们直接运行这条<code>ut</code>时，结果可想而知，我们什么还没实现呢，一定是错的！<br />
<img src="/assets/images/promise-ut01.png" alt="" /></p>

<p>那我们来试着满足下这个<code>ut</code>?</p>

<pre><code class="language-javascript">'use strict';

var Promise = function(func) {
    this._resolve = null;
    var promise = this;

    var resolver = function() {
        //当ut中调用resolve方法时，调用在then里赋值的_resolve
        promise._resolve();
    };

    var rejector = function() {};

    func(resolver, rejector);
};

Promise.prototype.then = function(onFulfilled, onRejected) {
    //`then`被调用时，将`onFulfilled`赋值给this._resolve
    this._resolve = onFulfilled;
};

module.exports = Promise;
</code></pre>

<p>试试再跑下<code>ut</code><br />
<img src="/assets/images/promise-ut02.png" alt="" /><img src="/assets/images/promise-cry.jpg" alt="" /></p>

<p>为什么会这样！？ 我们精心设计的<code>_resolve</code>为什么<code>is not a function</code>？</p>

<p>哪里有地方不对哦，我们仔细分析下啊：</p>

<p>实例化<code>Promise</code>对象时，传入了<code>func</code> -&gt;<br />
<code>func</code>在传入后就立即执行了 -&gt;  <br />
<code>func</code>里又直接调用了<code>resolver</code> -&gt;<br />
<code>resolver</code> 里调用了 <code>promise._resolve()</code></p>

<p>问题找到了，执行<code>promise._resolve()</code>时，<code>then</code>压根儿还没执行，也就是说，<code>promise._resolve</code>仍然是<code>null</code>。</p>

<p>找到问题，那就改进吧，我们是不是只要把<code>promise._resolve</code>的调用放到主线程外的任务队列里，等当前执行栈没事做以后，再从任务队列里取出来执行，这样的话<code>then</code>方法就在<code>promise._resolve</code>之前执行了：</p>

<p>关于<code>任务队列</code>、<code>执行栈</code>的详细背景，参考这里：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop">event-loop</a></p>

<pre><code class="language-javascript">'use strict';

var Promise = function(func) {
    this._resolve = null;
    var promise = this;

    var resolver = function() {
        process.nextTick(function() {
            promise._resolve();
        });
    };

    var rejector = function() {};

    func(resolver, rejector);
};

Promise.prototype.then = function(onFulfilled, onRejected) {
    this._resolve = onFulfilled;
};

module.exports = Promise;
</code></pre>
<blockquote>
  <p><code>process.nextTick</code>是个什么鬼？简单说，就是个高效版的<code>setTimeout</code>，由于不是今天重点，详情看这里<a href="https://nodejs.org/api/process.html#process_process_nexttick_callback_arg">process.nextTick</a></p>
</blockquote>

<p>再来跑下<code>ut</code>试试吧<br />
<img src="/assets/images/promise-ut03.png" alt="" /><img src="/assets/images/promise-happy.jpg" alt="" /></p>

<p><br /></p>

<h4 id="chainable"><code>chainable</code>的小心眼儿</h4>

<p>盆友们一定又要生气了，“这是个我的大腿，人家的<code>Promise</code>都能链式调用，你教我们的这个能吗、能吗、能吗？重要的事儿，问你三遍”。</p>

<p>好吧，既然谈到了<code>chainable</code>，那写个<code>ut</code>来测一下？</p>

<pre><code class="language-javascript">'use strict';
var PPP = require('../Promise');

describe('Promise', function() {
    it('chainable with immediately evaluated value returned', function(done) {
        var onFulfilled = sinon.stub().returns('Hello');
        var onFulfilledSec = sinon.spy();

        new PPP(function(resolve, reject) {
            resolve();
        })
        .then(onFulfilled)
        .then(onFulfilledSec);

        setTimeout(function() {
            //验证第一个then的回调被调用了1次
            should(onFulfilled.callCount).be.eql(1);
            //验证第二个then的回调被调用时传入了Hello作为参数
            should(onFulfilledSec.calledWith('Hello')).be.true();
            done();
        }, 100);
    });
});
</code></pre>
<p>好凄凉的赶脚！她，不work！</p>

<p><img src="/assets/images/promise-ut04.png" alt="" /><img src="/assets/images/promise-crash.jpg" alt="" /></p>

<p>问题略明显，因为我在<code>Promise</code>的<code>then</code>里只做了赋值，没有返回值。所以当我们要链式调用时，实际上相当于<code>undefined.then()</code>，那自然第二个<code>then</code>调用就必然失败了。</p>

<p>给个返回值怎么样？</p>

<pre><code class="language-javascript">'use strict';

var Promise = function(func) {
    this._resolve = null;
    var promise = this;

    var resolver = function() {
        process.nextTick(function() {
            promise._resolve();
        });
    };

    var rejector = function() {};

    func(resolver, rejector);
};

Promise.prototype.then = function(onFulfilled, onRejected) {
    this._resolve = onFulfilled;
    return this;//返回当前Promise
};

module.exports = Promise;
</code></pre>

<p>结果如何？<code>onFulfilled</code>肿么没被执行啊！</p>

<p><img src="/assets/images/promise-ut05.png" alt="" /><img src="/assets/images/promise-hehe.jpg" alt="" /></p>

<p>莫哭，原因时这样的，<code>then</code>里我们这样写的<code>this._resolve = onFulfilled;</code>，有感脚了吧，当<code>ut</code>里，第二次调用<code>then</code>时，实际上在<code>Promise</code>里，<code>_resolve</code>已经被第二次传入的<code>onFulfilledSec</code>覆盖了，所以该<code>Promise</code>在执行时，永远只有第二个<code>onFulfilledSec</code>被执行。</p>

<p>知错就要改，我们把<code>_resolve</code>改成数组吧：</p>

<pre><code class="language-javascript">'use strict';

var Promise = function(func) {
    this._resolves = [];
    var promise = this;

    var resolver = function() {
        process.nextTick(function() {
            promise._resolves.forEach(function(resolve) {
                resolve();
            });
        });
    };

    var rejector = function() {};

    func(resolver, rejector);
};

Promise.prototype.then = function(onFulfilled, onRejected) {
    this._resolves.push(onFulfilled);
    return this;
};

module.exports = Promise;
</code></pre>

<p><code>onFulfilled</code>没被执行的问题是解决了，不过<code>onFulfilledSec</code>执行时，应该传入<code>onFulfilled</code>的返回值这条，又错了。</p>

<p><img src="/assets/images/promise-ut06.png" alt="" /></p>

<p>原因不难分析，我们在执行<code>_resolves</code>时，是直接来了个<code>forEach</code>，各<code>resolve</code>被执行时并没有依赖前一个的执行结果。知错能改，在盆友们哭泣之前，我们再改：</p>

<pre><code class="language-javascript">'use strict';

var Promise = function(func) {
    this._resolves = [];
    var promise = this;

    var resolver = function() {
        process.nextTick(function() {
            //使用reduce函数，将每次的执行结果传给了下一个函数
            promise._resolves.reduce(function(previous, resolve) {
                return resolve(previous);
            }, undefined);
        });
    };

    var rejector = function() {};

    func(resolver, rejector);
};

Promise.prototype.then = function(onFulfilled, onRejected) {
    this._resolves.push(onFulfilled);
    return this;
};

module.exports = Promise;
</code></pre>

<p>有木有帅爆了的赶脚？？！</p>

<p><img src="/assets/images/promise-ut07.png" alt="" /></p>

<p><br /></p>

<h4 id="thenpromise"><code>then</code>里面如果返回的也是个<code>Promise</code>呢？</h4>

<p>来吧，先改<code>ut</code>：</p>

<pre><code class="language-javascript">'use strict';
var PPP = require('../Promise');

describe('Promise', function() {
    it('chainable with promise returned', function(done) {
        var onFulfilled = function() {
            return new PPP(function(resolve, reject) {
                resolve('Hello');
            });
        };
        var onFulfilledSec = sinon.spy();

        new PPP(function(resolve, reject) {
            resolve();
        })
        .then(onFulfilled)
        .then(onFulfilledSec);

        setTimeout(function() {
            //检查onFulfilledSec是否被调用，并且调用时是否传入了Hello作为参数
            should(onFulfilledSec.calledWith('Hello')).be.true();
            done();
        }, 100);
    });
});
</code></pre>

<p>不用问，按照我们刚才<code>reduce</code>的实现方式，这个<code>ut</code>一定是跑不过的。那我们就得把<code>Promise</code>里的<code>_resolves</code>“同步”执行，请看下解：</p>

<pre><code class="language-javascript">'use strict';

var Promise = function(func) {
    this._resolves = [];
    var promise = this;

    var handler = function(i, previous) {
        if (i === promise._resolves.length) {
            return;
        }
        var result = promise._resolves[i](previous);
        if (result instanceof Promise) {
            result.then(function(data) {
                handler(i + 1, data);
            });
            return;
        }
        handler(i + 1, result);
    };

    var resolver = function(data) {
        process.nextTick(function() {
            handler(0, data);
        });
    };

    var rejector = function() {};

    func(resolver, rejector);
};

Promise.prototype.then = function(onFulfilled, onRejected) {
    this._resolves.push(onFulfilled);
    return this;
};

module.exports = Promise;
</code></pre>
<p>万岁，离人生巅峰又进一步了！</p>

<p><img src="/assets/images/promise-ut08.png" alt="" /><img src="/assets/images/promise-right.jpg" alt="" /></p>

<p><br /></p>

<h4 id="reject">出错了肿么办？看了半天，也没见你写<code>reject</code>啊？</h4>

<p>没问题，先来改<code>ut</code></p>

<pre><code class="language-javascript">'use strict';
var PPP = require('../Promise');

describe('Promise', function() {

    it('catch with error message', function(done) {
        var err = new Error('fuck');
        var onFirstCall = sinon.spy();
        var onErrorHandler = sinon.spy();

        new PPP(function(resolve, reject) {
            //reject最初的Promise
            reject(err);
        })
            .then(onFirstCall, onErrorHandler);

        setTimeout(function() {
            //检查onFirstCall是否被调用
            should(onFirstCall.called).be.false();
            //检查onErrorHandler是否被执行，并且调用时是否传入了err作为参数
            should(onErrorHandler.calledWith(err)).be.true();
            done();
        }, 100);
    });

    it('catch with error', function(done) {
        var onFirstCall = sinon.spy();
        var onErrorHandler = function() {
            return new PPP(function(resolve, reject) {
                resolve('I_AM_BACK');
            })
        };
        var onSecondCall = sinon.spy();

        new PPP(function(resolve, reject) {
            reject(new Error('fuck'));
        })
        .then(onFirstCall, onErrorHandler)
        .then(onSecondCall);

        setTimeout(function() {
            //检查onFirstCall一定没有被调用
            should(onFirstCall.called).be.false();
            //检查onSecondCall被调用时传入了I_AM_BACK作为参数
            should(onSecondCall.calledWith('I_AM_BACK')).be.true();
            done();
        }, 100);
    });
});
</code></pre>
<p>不过<code>then</code>方法我们都没处理过<code>onRejected</code>参数，先来改改吧：</p>

<pre><code class="language-javascript">'use strict';

var Promise = function(func) {
    this._resolves = [];
    this._rejectors = [];
    var promise = this;

    var handler = function(i, previous, useRejector) {
        if (i === promise._resolves.length) {
            return;
        }
        var result;
        try {
            result = promise[useRejector ? '_rejectors' : '_resolves'][i](previous);

            //如果运行结果就是Promise，那需要在then时再回调下一个handler
            if (result instanceof Promise) {
                result.then(function(data) {
                    handler(i + 1, data);
                }, function(err) {
                    //如果Promise被reject了，调用下一个rejector
                    handler(i + 1, err, true);
                });
                return;
            }
            //如果不是Promise，直接调用下一个handler，并将结果传入
            handler(i + 1, result);
        } catch (e) {
            //运行时如果有异常，调用下一个rejector
            handler(i + 1, e, true);
        }
    };

    var resolver = function(data) {
        process.nextTick(function() {
            handler(0, data);
        });
    };

    var rejector = function(err) {
        process.nextTick(function() {
            handler(0, err, true);
        });
    };

    func(resolver, rejector);
};

Promise.prototype.then = function(onFulfilled, onRejected) {
    this._resolves.push(onFulfilled);
    this._rejectors.push(onRejected);
    return this;
};

module.exports = Promise;
</code></pre>

<p>酷，最后一战也成功了！</p>

<p><img src="/assets/images/promise-confidence.jpeg" alt="" /></p>

<p>本帖中的<a href="https://en.wikipedia.org/wiki/Unit_testing">unit test</a>使用<a href="https://mochajs.org/">mocha</a>编写，其中断言部分使用<a href="http://shouldjs.github.io/">shouldjs</a>，mock部分使用<a href="http://sinonjs.org/">sinonjs</a>。</p>

<p>整篇代码基于<a href="https://nodejs.org/">nodejs</a>环境编写。</p>

<p>同志们，<code>Promise</code>的内心世界，我们就探秘到这里吧！不过大家不要so naive的认为这就是一个<code>Promise</code>的一切。实际上用于生产化的<code>Promise</code>类库还涉及状态控制、参数校验、性能调教等不少内容，但是作为一个使用者，了解本章的内容，也就基本掌握了<code>Promise</code>的工作原理，对于我们今后在工作中使用<code>Promise</code>将大有裨益。</p>

<p>最后再次强调，本文只为探索<code>Promise</code>的实现原理，我尽量使用平实、简洁的方式实现了最最基本的功能，不代表市面上已存在的类库会用相同的写法处理需求，请一定不要参考了某<code>Promise</code>实现的源码后来问，为什么和我写的不一样，谢谢！</p>


        <div class="right-align pagination-group">
            
                <a href="/tech/2015/07/06/javascript-interview" class="btn waves-effect waves-light blue lighten-2" style="border-top-right-radius: 0; border-bottom-right-radius: 0;">
                    &larr; <span lang="PREVIOUS_BTN"></span>
                </a>
            
                <a href="/archive.html" class="btn waves-effect waves-light blue" style="border-radius: 0;" lang="ARCHIVE_BTN"></a>
            
                <a href="/tech/2015/12/10/create-web-slides" class="btn waves-effect waves-light blue lighten-2" style="border-top-left-radius: 0; border-bottom-left-radius: 0;">
                    <span lang="NEXT_BTN"></span> &rarr;
                </a>
            
        </div>
        
        <br/>
        <hr>

        


  <div class="ds-thread" data-thread-key="/tech/2015/11/07/writing-your-own-promise" data-title="一步步教你手写Promise" data-url="http://leftstick.gitcafe.io/tech/2015/11/07/writing-your-own-promise"></div>
<script type="text/javascript">
var duoshuoQuery = {short_name:"leftstickgithub"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>




    </div>
    <div class="col m4 hide-on-small-only">
        <div class="card blue-grey darken-1 z-depth-2">
            <div class="card-content white-text">
              <span class="card-title">一步步教你手写Promise</span>
            </div>
            <div class="card-action blue-grey lighten-4">
                <span lang="CREATED_ON"></span> 2015-11-07
            </div>
        </div>

        <div class="card-panel grey lighten-5 z-depth-2">
            <div class="row valign-wrapper">
                <div class="col s12">
                    <i class="fa fa-server fa-lg grey-text text-darken-4"></i>&nbsp;&nbsp;<strong class="grey-text text-darken-4" lang="CATEGORIES"></strong>
                    <hr>
                    
                      
                      <a href="/categories.html#tech-ref" class="waves-effect waves-light btn tag deep-orange">
                          tech&nbsp;11
                      </a>
                      
                    
                </div>
            </div>
        </div>

        <div class="card-panel grey lighten-5 z-depth-2">
            <div class="row valign-wrapper">
                <div class="col s12">
                    <i class="fa fa-flag fa-lg grey-text text-darken-4"></i>&nbsp;&nbsp;<strong class="grey-text text-darken-4" lang="TAGS"></strong>
                    <hr>
                    
                      
                      <a href="/tags.html#Promise-ref" class="waves-effect waves-light btn tag deep-orange">
                          Promise&nbsp;1
                      </a>
                      
                      <a href="/tags.html#JavaScript-ref" class="waves-effect waves-light btn tag deep-orange">
                          JavaScript&nbsp;3
                      </a>
                      
                    
                </div>
            </div>
        </div>
    </div>
</div>

          </div>
      </main>

      <div class="goto-top hide-on-med-and-down">
          <i class="fa fa-chevron-up fa-2x"></i>
      </div>

      <footer class="page-footer" style="padding-top:0;">
          
          <div class="footer-copyright">
            <div class="container">
            &copy; 2016 Howard.Zuo, All rights reserved.
            <a class="grey-text text-lighten-4 right" href="https://github.com/leftstick/jekyll-materiallize/blob/master/LICENSE">MIT License</a>
            </div>
          </div>
      </footer>

      


      <!-- Placed at the end of the document so the pages load faster -->
      <script src="/assets/themes/materiallize/js/jquery-2.1.3.min.js"></script>
      <script src="/assets/themes/materiallize/js/materialize.min.js"></script>
      <script src="/assets/themes/materiallize/js/jquery.tooltipster.min.js"></script>
      <script src="/assets/themes/materiallize/js/prism.js"></script>
      <script src="/assets/themes/materiallize/js/prism.clojure.js"></script>
      <script src="/assets/lang/lang.js"></script>
      <script src="/assets/themes/materiallize/js/init.js"></script>
  </body>
</html>

