<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>[译]JavaScript中的不可变性(Immutability) | 右领军大都督</title>
    <meta name="description" content="不可变性(Immutability)是函数式编程的核心原则，在面向对象编程里也有大量应用。在这篇文章里，我会给大家秀一下到底什么是不可变性(Immutability)、她为什么还这么屌、以及在JavaScript中怎么应用。

什么是不可变性(Immutability)？

还是先来看看关于可变性(Mutability)的教条式定义：“liable or subje ...">
    <meta name="generator" content="VuePress 1.4.0">
    
    
    <link rel="preload" href="/assets/css/0.styles.ff698ad4.css" as="style"><link rel="preload" href="/assets/js/app.66fd165c.js" as="script"><link rel="preload" href="/assets/js/6.1b9a181a.js" as="script"><link rel="preload" href="/assets/js/4.718a8abf.js" as="script"><link rel="preload" href="/assets/js/36.573317d5.js" as="script"><link rel="prefetch" href="/assets/js/1.836aefc7.js"><link rel="prefetch" href="/assets/js/10.5978e5d8.js"><link rel="prefetch" href="/assets/js/11.ec890499.js"><link rel="prefetch" href="/assets/js/12.db7bcb86.js"><link rel="prefetch" href="/assets/js/13.a0678d0c.js"><link rel="prefetch" href="/assets/js/14.db66846d.js"><link rel="prefetch" href="/assets/js/15.2591b2da.js"><link rel="prefetch" href="/assets/js/16.80583441.js"><link rel="prefetch" href="/assets/js/17.0753be43.js"><link rel="prefetch" href="/assets/js/18.72780206.js"><link rel="prefetch" href="/assets/js/19.1d487c74.js"><link rel="prefetch" href="/assets/js/20.f0fe9a95.js"><link rel="prefetch" href="/assets/js/21.d80a0f41.js"><link rel="prefetch" href="/assets/js/22.4695553f.js"><link rel="prefetch" href="/assets/js/23.52e4eec9.js"><link rel="prefetch" href="/assets/js/24.bf9c9350.js"><link rel="prefetch" href="/assets/js/25.5eb98d81.js"><link rel="prefetch" href="/assets/js/26.17cf0ede.js"><link rel="prefetch" href="/assets/js/27.522aaf5a.js"><link rel="prefetch" href="/assets/js/28.f0f1746b.js"><link rel="prefetch" href="/assets/js/29.7185f335.js"><link rel="prefetch" href="/assets/js/30.84d20b8c.js"><link rel="prefetch" href="/assets/js/31.c51c0b21.js"><link rel="prefetch" href="/assets/js/32.7d842090.js"><link rel="prefetch" href="/assets/js/33.9948fc6c.js"><link rel="prefetch" href="/assets/js/34.03615f5c.js"><link rel="prefetch" href="/assets/js/35.916ec328.js"><link rel="prefetch" href="/assets/js/37.766086c8.js"><link rel="prefetch" href="/assets/js/38.b2d6547e.js"><link rel="prefetch" href="/assets/js/39.f52d00bf.js"><link rel="prefetch" href="/assets/js/40.fffe6b1e.js"><link rel="prefetch" href="/assets/js/41.d2951850.js"><link rel="prefetch" href="/assets/js/42.1d2dcebb.js"><link rel="prefetch" href="/assets/js/43.8e48cd61.js"><link rel="prefetch" href="/assets/js/44.8303cf21.js"><link rel="prefetch" href="/assets/js/45.39ad8d71.js"><link rel="prefetch" href="/assets/js/5.6e87a095.js"><link rel="prefetch" href="/assets/js/7.01c41c5e.js"><link rel="prefetch" href="/assets/js/8.b9ecde8b.js"><link rel="prefetch" href="/assets/js/9.a3929d94.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.da6e1ebe.js">
    <link rel="stylesheet" href="/assets/css/0.styles.ff698ad4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/" class="nav-link home-link">右领军大都督 </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/" class="nav-link">Blog</a></li><li class="nav-item"><a href="/tag/" class="nav-link">Tags</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/" class="nav-link mobile-home-link">右领军大都督 </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/" class="nav-link">Blog</a></li><li class="mobile-nav-item"><a href="/tag/" class="nav-link">Tags</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        [译]JavaScript中的不可变性(Immutability)
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">Howard Zuo</span> <span itemprop="address">   in Shanghai</span></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2016-04-09T00:00:00.000Z">
      Sat Apr 09 2016
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-d832e844><a href="/tag/immutability" data-v-d832e844> immutability </a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><p>不可变性(<code>Immutability</code>)是函数式编程的核心原则，在面向对象编程里也有大量应用。在这篇文章里，我会给大家秀一下到底什么是不可变性(<code>Immutability</code>)、她为什么还这么屌、以及在<code>JavaScript</code>中怎么应用。</p> <h2 id="什么是不可变性-immutability-？"><a href="#什么是不可变性-immutability-？" class="header-anchor">#</a> 什么是不可变性(<code>Immutability</code>)？</h2> <p>还是先来看看关于可变性(<code>Mutability</code>)的教条式定义：“liable or subject to change or alteration(译者注：真他妈难翻，就简单理解成'易于改变的'吧)”。在编程领域里，我们用可变性(<code>Mutability</code>)来描述这样一种对象，它在创建之后状态依旧可被改变。那当我们说不可变(<code>Immutable</code>)时，就是可变(<code>Mutable</code>)的对立面了(译者注：原谅我翻的废话又多起来) － 意思是，创建之后，就再也不能被修改了。</p> <p>如果我说的又让你感到诡异了，原谅我小小的提醒一下，其实我们平时使用的很多东西事实上都是不可变的哦！</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> statement <span class="token operator">=</span> <span class="token string">'I am an immutable value'</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> otherStr <span class="token operator">=</span> statement<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我猜没人会吃惊，<code>statement.slice(8, 17)</code>并没有改变<code>statement</code>变量吧(译者注：如果你吃惊了，赶紧去补基本知识吧)？事实上，<code>string</code>对象上的所有方法里，没有一个会修改原<code>string</code>，它们一律返回新的<code>string</code>。原因简单了，因为<code>string</code>就是是不可变的(<code>Immutable</code>) - 它们不能被修改，我们能做的就是基于原<code>string</code>操作后得到一个新<code>string</code>。</p> <p>注意了，<code>string</code>可不是<code>JavaScript</code>里唯一内置的不可变(<code>Immutable</code>)数据类型哦。<code>number</code>也是不可变(<code>Immutable</code>)的。否则的话，你试想下这个表达式<code>2 + 3</code>，如果<code>2</code>的含义能被修改，那代码该怎么写啊|_|。听起来荒谬吧，但我们在编程中却常常对<code>object</code>和<code>array</code>做出这种事儿。</p> <h2 id="javascript充满变化"><a href="#javascript充满变化" class="header-anchor">#</a> JavaScript充满变化</h2> <p>在<code>JavaScript</code>中，<code>string</code>和<code>number</code>从设计之初就是不可变(<code>Immutable</code>)的。但是，看看下面这个关于<code>array</code>例子：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> v2 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>来我问你，<code>v2</code>的值是什么？如果<code>array</code>和<code>string</code>、<code>number</code>一样也是不可变(<code>Immutable</code>)的，那此时<code>v2</code>必定是一个包含了一个数字<code>2</code>的新<code>array</code>。事实上，还真就不是那样的。这里<code>arr</code>引用的<code>array</code>被修改了，里面添了一个数字<code>2</code>，这时<code>v2</code>的值(也就是<code>arr.push(2)</code>的返回值)，其实是<code>arr</code>此时的长度 － 就是<code>1</code>。</p> <p>试想我们拥有一个不可变的数组(<code>ImmutableArray</code>)。就像<code>string</code>、<code>number</code>那样，她应该能像如下这样被使用：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ImmutableArray</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> v2 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

arr<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, 2, 3, 4]</span>
v2<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// [1, 2, 3, 4, 5]</span>
</code></pre></div><p>类似的，也可以有一个不可变的Map(<code>ImmutableMap</code>)，理论上可以替代<code>object</code>应该于多数场景，她应该有一个<code>set</code>方法，不过这个<code>set</code>方法不会塞任何东西到原<code>Map</code>里，而是返回一个包含了塞入值的新<code>Map</code>：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ImmutableMap</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">'Chris'</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token number">32</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> olderPerson <span class="token operator">=</span> person<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'age'</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

person<span class="token punctuation">.</span><span class="token function">toObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {name: 'Chris', age: 32}</span>
olderPerson<span class="token punctuation">.</span><span class="token function">toObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {name: 'Chris', age: 33}</span>
</code></pre></div><p>就像<code>2 + 3</code>这个表达式里，我们不可能改变<code>2</code>或是<code>3</code>所代表的含义，一个<code>person</code>在庆祝他33岁的生日，并不会影响他曾经是32岁的事实。</p> <h2 id="javascript不可变性-immutability-实战"><a href="#javascript不可变性-immutability-实战" class="header-anchor">#</a> JavaScript不可变性(<code>Immutability</code>)实战</h2> <p><code>JavaScript</code>里目前还没有不可变的<code>list</code>和<code>map</code>，所以暂时我们还是需要三方库的帮助。有两个很不错的，一个是<a href="https://github.com/swannodette/mori" target="_blank" rel="noopener noreferrer">Mori<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> － 她把<code>ClojureScript</code>里持久化数据结构的API支持带到了<code>JavaScript</code>里；另一个是Facebook出品的<a href="https://github.com/facebook/immutable-js" target="_blank" rel="noopener noreferrer">immutable.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。后面的示例里，我将使用<a href="https://github.com/facebook/immutable-js" target="_blank" rel="noopener noreferrer">immutable.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，因为她的API对于<code>JavaScript</code>开发者更友好一些。</p> <p>下面的例子里，我们使用不可变(<code>Immutable</code>)知识来构建一个扫雷小游戏。扫雷的游戏面板我们用一个不可变的<code>map</code>来构建，其中<code>tiles</code>(雷区区块)部分值得关注哦，它是一个由不可变<code>map</code>组成的不可变<code>list</code>(译者注：又开始绕了)，其中每一个不可变的<code>map</code>表示一个<code>tile</code>(雷区块)。整个这个雷区面板都是由<code>JavaScript</code>的<code>object</code>和<code>array</code>组成的，最后由<a href="https://github.com/facebook/immutable-js" target="_blank" rel="noopener noreferrer">immutable.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的<code>fromJS</code>方法对其进行不可变化处理：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">createGame</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Immutable<span class="token punctuation">.</span><span class="token function">fromJS</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    cols<span class="token operator">:</span> options<span class="token punctuation">.</span>cols<span class="token punctuation">,</span>
    rows<span class="token operator">:</span> options<span class="token punctuation">.</span>rows<span class="token punctuation">,</span>
    tiles<span class="token operator">:</span> <span class="token function">initTiles</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>rows<span class="token punctuation">,</span> options<span class="token punctuation">.</span>cols<span class="token punctuation">,</span> options<span class="token punctuation">.</span>mines<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>剩下的主要逻辑部分就是“扫雷”了，传入扫雷游戏对象(一个不可变结构)做为第一个参数，以及要“扫”的那个<code>tile</code>(雷区块)对象，最后返回新的扫雷游戏实例。以下我们就要讲到这个<code>revealTile</code>函数。当它被调用时，<code>tile</code>(雷区块)的状态就要被重置为“扫过”的状态。如果是可变编程，代码很简单：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">revealTile</span><span class="token punctuation">(</span><span class="token parameter">game<span class="token punctuation">,</span> tile</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  game<span class="token punctuation">.</span>tiles<span class="token punctuation">[</span>tile<span class="token punctuation">]</span><span class="token punctuation">.</span>isRevealed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后再来看看如果用上面介绍的不可变数据结构来编码，坦白讲，一开始代码变得都点丑了：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">revealTile</span><span class="token punctuation">(</span><span class="token parameter">game<span class="token punctuation">,</span> tile</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> updatedTile <span class="token operator">=</span> game<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'tiles'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>tile<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'isRevealed'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> updatedTiles <span class="token operator">=</span> game<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'tiles'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>tile<span class="token punctuation">,</span> updatedTile<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> game<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'tiles'</span><span class="token punctuation">,</span> updatedTiles<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我去，丑爆了有木有！</p> <p>万幸，不可变性不止于此，一定有得救！这种需求很常见，所以工具早就考虑到了，可以这么操作：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">revealTile</span><span class="token punctuation">(</span><span class="token parameter">game<span class="token punctuation">,</span> tile</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> game<span class="token punctuation">.</span><span class="token function">setIn</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'tiles'</span><span class="token punctuation">,</span> tile<span class="token punctuation">,</span> <span class="token string">'isRevealed'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在<code>revealTile</code>返回一个新的实例了，新实例里其中一个<code>tile</code>(雷区块)的<code>isRevealed</code>就和之前那个<code>game</code>实例里的不一样了。这里面用到的<code>setIn</code>是一个<code>null-safe</code>(空值安全)的函数，任意<code>keyPath</code>中的<code>key</code>不存在时，都会在这个位置创建一个新的不可变<code>map</code>(译者注：这句略绕，个人认为既然这里不是主讲<a href="https://github.com/facebook/immutable-js" target="_blank" rel="noopener noreferrer">immutable.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，那就没必要非提一下它的这个特性，反而不清不楚，原作没细说，那我也就不多说了，有兴趣的可以<a href="http://facebook.github.io/immutable-js/docs/#/Map/setIn" target="_blank" rel="noopener noreferrer">来这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>自己揣摩)。这个<code>null-safe</code>特性对于我们现在扫雷游戏这个例子并不合适，因为“扫”一个不存在的<code>tile</code>(雷区块)表示我们正在试图扫雷区以外的地方，那显然不对！这里需要多做一步检查，通过<code>getIn</code>方法检查<code>tile</code>(雷区块)是否存在，然后再“扫”它：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">revealTile</span><span class="token punctuation">(</span><span class="token parameter">game<span class="token punctuation">,</span> tile</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> game<span class="token punctuation">.</span><span class="token function">getIn</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'tiles'</span><span class="token punctuation">,</span> tile<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span>
    game<span class="token punctuation">.</span><span class="token function">setIn</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'tiles'</span><span class="token punctuation">,</span> tile<span class="token punctuation">,</span> <span class="token string">'isRevealed'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">:</span>
    game<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果<code>tile</code>(雷区块)不存在，我们就返回原扫雷游戏实例。这就是个可迅速上手的关于不可变性(<code>Immutability</code>)的练习，想深入了解的可以看<a href="http://codepen.io/SitePoint/pen/zGYZzQ" target="_blank" rel="noopener noreferrer">codepen<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，完整的实现都在里面了。</p> <h2 id="performance怎么样"><a href="#performance怎么样" class="header-anchor">#</a> Performance怎么样?</h2> <p>你可能觉得，这他妈Performance应该low爆了吧，我只能说某些情况下你是对的。每当你想添加点东西到一个不可变(<code>Immutable</code>)对象里时，她一定是先拷贝以存在值到新实例里，然后再给新实例添加内容，最后返回新实例。相比可变对象，这势必会有更多内存、计算量消耗。</p> <p>因为不可变(<code>Immutable</code>)对象永远不变，实际上有一种实现策略叫“结构共享”，使得她的内存消耗远比你想象的少。虽然和内置的<code>array</code>、<code>object</code>的“变化”相比仍然会有额外的开销，但这个开始恒定，绝对可以被不可变性(<code>Immutability</code>)带来的其它众多优势所消磨、减少。在实践中，不可变性(<code>Immutability</code>)带来的优势可以极大的优化程序的整体性能，即使其中的某些个别操作开销变大了。</p> <h2 id="改进变更追踪"><a href="#改进变更追踪" class="header-anchor">#</a> 改进变更追踪</h2> <p>各种UI框架里，最难的部分永远是变更追踪(译者注：或者叫“脏检查”)。这是<code>JavaScript</code>社区里的普遍问题，所以EcmaScript 7里提供了单独的API在保证Performance的前提下可以追踪变化：<code>Object.observe()</code>。很多人为之激动，但也有不少人认为这个API然并卵。他们认为，在任何情况下，这个API都没很好的解决变更追踪问题：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> tiles <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>id<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> isRevealed<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> isRevealed<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>tiles<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

tiles<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre></div><p>上面例子里，<code>tiles[0]</code>的变更并没有触发<code>observer</code>，所以其实这个提案即便是最简单的变更追踪也没做到。那不可变性(<code>Immutability</code>)又是怎么解决的？假设有一个应用状态<code>a</code>，然后它内部有值被改变了，于是就得到了一个新的实例<code>b</code>：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">===</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 数据没变，停止操作</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果应用状态<code>a</code>没有被修改，那<code>b</code>就是<code>a</code>，它们指向同一个实例，<code>===</code>就够了，不用做其他事儿。当然这需要我们追踪应用状态的引用，但整个问题的复杂度被大大简化了，现在只要判断一下它们是否同一个实例的引用就好了，真心不用再去深入调查里面的某某字段是不是变了。</p> <h2 id="结束语"><a href="#结束语" class="header-anchor">#</a> 结束语</h2> <p>希望本文能某种程度上帮你了解不可变性(<code>Immutability</code>)是如何帮我们优化/改进代码的，也希望这些例子从实践角度说清楚了使用方式。不可变性(<code>Immutability</code>)的热度在持续增高，我确定这绝不是你今年看到的关于不可变性(<code>Immutability</code>)的最后一文。同志们，是时候来一发了，我相信你用过后一定会high至的，就像我现在一样^^。</p> <p>原文地址：<a href="http://www.sitepoint.com/immutability-javascript/" target="_blank" rel="noopener noreferrer">Immutability in JavaScript<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#什么是不可变性-immutability-？" title="什么是不可变性(Immutability)？">什么是不可变性(Immutability)？</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#javascript充满变化" title="JavaScript充满变化">JavaScript充满变化</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#javascript不可变性-immutability-实战" title="JavaScript不可变性(Immutability)实战">JavaScript不可变性(Immutability)实战</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#performance怎么样" title="Performance怎么样?">Performance怎么样?</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#改进变更追踪" title="改进变更追踪">改进变更追踪</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#结束语" title="结束语">结束语</a></div></div></div></div> <footer class="footer" data-v-fdbf4940><div class="footer-left-wrap" data-v-fdbf4940><ul class="contact" data-v-fdbf4940></ul></div> <div class="footer-right-wrap" data-v-fdbf4940><ul class="copyright" data-v-fdbf4940></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.66fd165c.js" defer></script><script src="/assets/js/6.1b9a181a.js" defer></script><script src="/assets/js/4.718a8abf.js" defer></script><script src="/assets/js/36.573317d5.js" defer></script>
  </body>
</html>
